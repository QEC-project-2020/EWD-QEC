import os
import sys
import getopt
import time
import subprocess
import argparse

import numpy as np

from src.toric_model import *
from src.planar_model import *
from src.util import Action


class MWPM():
    def __init__(self, code):
        assert type(code) in (Toric_code, Planar_code), 'code has to be either Planar_code or Toric_code'
        self.code = code
        self.is_planar = (type(code) == Planar_code)

    def get_shortest_distance(self, defect1, defect2):
        # Planar_code only cares about direct path
        if self.is_planar:
            return manhattan_path(defect1, defect2).sum()
        # Toric_code has to take periodic path into account
        else:
            # Direct path
            non_periodic_path = manhattan_path(defect1, defect2)
            # Periodic path
            periodic_path = self.code.system_size - non_periodic_path
            # Minimum distance in each direction
            shortest_path = np.min(non_periodic_path, periodic_path, axis=1)
            # Total minimum distance
            return shortest_path.sum()

    def generate_MWPM(self, layer):
        # get defects in layer
        # planar has different names for different layers
        if self.is_planar:
            if layer == 0:
                defects = self.code.vertex_defects
            elif layer == 1:
                defects = self.code.plaquette_defects
        else:
            defects = self.code.current_state[layer]

        # array of coordniates of defects on the syndrom matrix
        defect_coords = np.array(np.nonzero(defects)).T

        # number of defects
        nbr_nodes = len(defect_coords)

        # each node is paired with each other node, so there are n(n-1)/2 edges
        nbr_edges = int(nbr_nodes * (nbr_nodes - 1) / 2)

        # generates node indices
        edges = self.generate_node_indices(layer)

        # builds arguments for the bloosom5 program
        processId = os.getpid()
        PATH = str(processId) + 'edges.TXT'
        OUTPUT_PATH = str(processId) +'output.TXT'

        # Save txt file with data for blossom5 to read
        header_str = "{} {}".format(nbr_nodes, nbr_edges)
        np.savetxt(PATH, edges, fmt='%i', header=header_str, comments='')

        # If on windows, the executable file ends in '.exe'
        blossomname = './src/blossom5-v2.05.src/blossom5'
        if os.name == 'windows':
            blossomname += '.exe'
        # Run the blossom5 program as if from the terminal. The devnull part discards any prints from blossom5
        subprocess.call([blossomname, '-e', PATH, '-w', OUTPUT_PATH, '-V'], stdout=open(os.devnull, 'wb'))

        # Read the output from blossom5 and delete the output file
        MWPM_edges = np.loadtxt(OUTPUT_PATH, skiprows=1, dtype=int)
        MWPM_edges = MWPM_edges.reshape((int(nbr_nodes/2), 2))

        # remove files generated by blossom5
        os.remove(PATH)
        os.remove(OUTPUT_PATH)

        return MWPM_edges, edges, defect_coords


    # generates an array of distinct node pairs and stores in edges[]
    def generate_node_indices(self, layer):
        # get defects in layer
        # planar has different names for different layers
        if self.is_planar:
            
            # array of coordinates of defects on the defect matrix
            if layer == 0:
                defect_coords = np.array(np.nonzero(self.code.vertex_defects)).T
            elif layer == 1:
                defect_coords = np.array(np.nonzero(self.code.plaquette_defects)).T
            
            # number of defects
            nbr_defects = defect_coords.shape[0]

        else:
            # array of coordinates of defects on the defect matrix
            defect_coords = np.array(np.nonzero(self.code.current_state[layer])).T
            # number of defects
            nbr_defects = defect_coords.shape[0]
        
        nbr_edges = int(nbr_defects * (nbr_defects - 1) / 2)

        # list of single-valued arrays of decreasing length and increasing value
        start_nodes, end_nodes = connect_all(nbr_defects)
        distances = [self.get_shortest_distance(defect_coords[start_nodes[edge]], defect_coords[end_nodes[edge]])
                for edge in range(nbr_edges)]

        if self.is_planar:
            # list of border each defect can match to
            # left/top border corresponds to 0; right/bottom corresponds to to 1
            borders = int(defect_coords[:, (not layer)] * 2 > self.code.system_size)
            nbr_ancilla_nodes_0, nbr_ancilla_nodes_1 = np.bincount(borders)
            nbr_ancilla_edges_0 = (nbr_ancilla_nodes_0 * (nbr_ancilla_nodes_0 - 1)) // 2
            nbr_ancilla_edges_1 = (nbr_ancilla_nodes_1 * (nbr_ancilla_nodes_1 - 1)) // 2

            # Connect all ancilla defects on the top/left
            ancilla_0_start, ancilla_0_end = connect_all(nbr_ancilla_nodes_0, nbr_defects)
            # put weight 0 on edges between ancilla defects
            ancilla_0_distances = [0] * nbr_ancilla_edges_0

            # Connect all ancilla defects on the bottom/right
            ancilla_1_start, ancilla_1_end = connect_all(nbr_ancilla_nodes_1, nbr_defects + nbr_ancilla_nodes_0)
            # put weight 0 on edges between ancilla defects
            ancilla_1_distances = [0] * nbr_ancilla_edges_1

            # connect all real defects with their corresponding ancilla defect
            border_start = [i for i in range(nbr_defects)]
            border_end = [nbr_defects + borders[start] * nbr_ancilla_nodes_0 + start for start in border_start]
            # weight of border edges is distance from defect to closest border
            border_distances = [min(defect_coords[defect, (not layer)], self.code.system_size - defect_coords[defect, (not layer)])
                    for defect in border_start]

            # append the lists of nodes with all the ancilla connections
            start_nodes += ancilla_0_start     + ancilla_1_start     + border_start
            end_nodes   += ancilla_0_end       + ancilla_1_end       + border_end
            distances   += ancilla_0_distances + ancilla_1_distances + border_distances

            # the number of edges is increased with all edges connecting to ancilla defects
            nbr_edges += nbr_defects + nbr_ancilla_edges_0 + nbr_ancilla_edges_1

        # store the lists of node connections and distances in array
        edges = np.zeros((nbr_edges, 3))
        edges[:, 0] = np.concatenate(start_nodes)
        edges[:, 1] = np.concatenate(end_nodes)
        edges[:, 2] = np.concatenate(distances)

        return edges


    def eliminate_defect_pair(self, start_coord, end_coord, layer):
        diff_coord = end_coord - start_coord
        system_size = self.code.system_size

        # if planar, only manhattan path is interesting
        if self.is_planar:
            nbr_vertical_steps = np.abs(diff_coord[0])
            nbr_horizontal_steps = np.abs(diff_coord[1])

        # if torus, both paths around torus are interesting
        else:
            # calculates manhattan distance between defects other way around torus
            size_diff = (np.array([system_size, system_size]) - np.abs(diff_coord)) % system_size

            # calculates shortest vertical and horizontal distance between defects
            nbr_vertical_steps = min(size_diff[0], np.abs(diff_coord[0]))
            nbr_horizontal_steps = min(size_diff[1], np.abs(diff_coord[1]))

        # translates the layer into x or z operators
        operator = (not layer) * 2 + 1

        correction = np.zeros_like(self.code.qubit_matrix)
        
        # HIT KOM JAG INNAN TIDEN TOG SLUT
        top, bot = sorted([start_coord[0], end_coord[0]])
        left, right = sorted([start_coord[1], end_coord[1]])
        #vertical
        correction[layer, top:bot, left]

        # iterate through vertical steps
        for i in range(nbr_vertical_steps):
            # choose direction around torus
            direction = size_diff[0]>np.abs(diff_coord[0])
            # calculate qubit coordinates to apply correction
            start_coord[0] = (start_coord[0] + direction-(not layer))%system_size
            # store qubit coordinates
            pos = [layer, start_coord[0], start_coord[1]]
            # update coordinate of defect
            start_coord[0] = (start_coord[0] - (not direction)+(not layer))%system_size

            # apply correction on torus
            action = Action(pos, operator)
            toric_code.step(action)
            toric_code.syndrom('state')

        # iterate through horizontal steps
        for i in range(nbr_horizontal_steps):
            # calculate coordinates of qubit to apply correction
            # and update coordinate of defect
            if (diff_coord[1] < 0):
                direction = size_diff[1]<np.abs(diff_coord[1])
                start_coord[1] = (start_coord[1] + (direction)-(not layer))%system_size
                pos = [int(not layer), start_coord[0], start_coord[1]]
                start_coord[1] = (start_coord[1] - (not direction))+(not layer)%system_size
            else:
                direction = size_diff[1]>np.abs(diff_coord[1])
                start_coord[1] = (start_coord[1] + (direction)-(not layer))%system_size
                pos = [int(not layer), start_coord[0], start_coord[1]]
                start_coord[1] = (start_coord[1] - (not direction)+(not layer))%system_size

            # apply correction on torus
            action = Action(pos, operator)
            toric_code.step(action)
            toric_code.syndrom('state')
        
        # return corrected torus
        return toric_code

# non periodic manhattan distance between defect at coord1 and coord2
def manhattan_path(defect1, defect2):
    x_distance = np.abs(defect1[0] - defect2[0])
    y_distance = np.abs(defect1[1] - defect2[1])
    return np.array([x_distance, y_distance])


def connect_all(nbr_nodes, index_offset=0):
    # list of lists where every node's index is repeated for every connection it 'starts'
    start = [[i + index_offset] * (nbr_nodes - i - 1) for i in range(nbr_nodes)]
    # list of lists with the indices of every 'end' node corresponding to the 'start' nodes above
    end = [[j + index_offset for j in range(i + 1, nbr_nodes)] for i in range(nbr_nodes)]

    return start, end

# given torus and defect pairs, this applies a correction connecting the pairs
def generate_solution(MWPM_edges, defect_coords, toric_code, matrix_index, system_size):
    # coordinates of pairs to connect
    start_coords = defect_coords[MWPM_edges[:, 0].T, :]
    end_coords = defect_coords[MWPM_edges[:, 1].T, :]

    # if there are defects on the torus
    if (np.sum(np.sum(toric_code.current_state[matrix_index])) > 0):
        # iterate through all the mwpm defect pairs
        for start_coord, end_coord in zip(start_coords, end_coords):
            # eliminate the current pair
            toric_code = eliminate_defect_pair(toric_code, start_coord, end_coord, matrix_index, system_size)
    return toric_code

def main(args):
    #TODO: add support for arguments
    # parser = argparse.ArgumentParser()
    # parser.add_argument('test2', help='test adsfadd')
    # parser.parse_args()
    # print(args.test2)
    # try:
    #     opts, args = getopt.getopt(argv, "hn:d:p:", ["help"])
    # except getopt.GetoptError as err:
    #     print(err)
    #     usage()
    #     sys.exit(2)
    # print(opts)
    # print(args)

    # for o, a in opts:
    #     print(o)
    #     if o in ("-h", "--help"):
    #         usage()
    #     elif o == "-d":
    #         system_size = int(a)
    #         print("d = {}".format(system_size))
    #     elif o == "-n":
    #         nbr_of_iterations = int(float(a))
    #         print(nbr_of_iterations)


    p_errors = [0.07]
    system_size = int(5)
    nbr_of_iterations = int(1e2)

    print(p_errors)
    ground_state_kept_list = []

    # iterate through p_errors
    for p in p_errors:
        print(p)
        ground_states = 0
        # iterate some number of times
        for _ in range(nbr_of_iterations):
            # create a torus and generate error according to p
            toric_code = Toric_code(system_size)
            nbr_of_vertex_nodes = 0
            nbr_of_plaquette_nodes = 0

            toric_code = generate_syndrome(toric_code, p)
            n = 3

            MWPM_edges_vertex = []
            edges_vertex = []
            edges_no_periodic_vertex = []
            defect_coords_vertex = []

            MWPM_edges_plaquette = []
            edges_plaquette = []
            edges_no_periodic_plaquette = []
            defect_coords_plaquette = []

            # if there are defects in a layer, connect pairs of defects with mwpm
            if np.sum(np.sum(toric_code.current_state[0])) > 0:
                MWPM_edges_vertex, edges_vertex, edges_no_periodic_vertex, defect_coords_vertex = generate_MWPM(toric_code.current_state[0], system_size)
            if np.sum(np.sum(toric_code.current_state[1])) > 0:
                MWPM_edges_plaquette, edges_plaquette, edges_no_periodic_plaquette, defect_coords_plaquette = generate_MWPM(toric_code.current_state[1], system_size)

            # connect defect pairs given by mwpm
            if len(MWPM_edges_vertex) > 0:
                toric_code = generate_solution(MWPM_edges_vertex, defect_coords_vertex, toric_code, 0, system_size)
            if len(MWPM_edges_plaquette) > 0:
                toric_code = generate_solution(MWPM_edges_plaquette, defect_coords_plaquette, toric_code, 1, system_size)

            # check for logical errors
            toric_code.eval_ground_state()
            ground_states += toric_code.ground_state

        ground_state_kept_list.append(ground_states/nbr_of_iterations)

    # store results
    #timestamp = time.ctime()
    try:
        os.mkdir('results')
    except FileExistsError:
        pass

    PATH_ground2 = 'results/p_succes_MWPM_d={}.TXT'.format(system_size)

    np.savetxt(PATH_ground2, ground_state_kept_list, fmt='%e', comments='')
    print(ground_state_kept_list)

if __name__ == "__main__":
    main(sys.argv[1:])
